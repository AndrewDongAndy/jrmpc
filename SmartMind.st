'From Pharo7.0.4 of 13 August 2019 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)] on 3 March 2020 at 11:21:15.643473 pm'!RobotMind subclass: #SmartMind	instanceVariableNames: 'INF MAX_ROWS MAX_COLS ROWS COLS DIRS MAX_DIST NODE_THRESHOLD DIST_WEIGHT WEIGHT_EXPONENT distThreshold robot allRobots otherRobots sortedRobots whereRobots moves mbeg mend cells dist gain lastCell lastDir q beg end movesLeft numTles bestNeighboursUsed backupMovesUsed neighbourDecisions lastDecision'	classVariableNames: ''	poolDictionaries: ''	category: 'JRMPC-Phase1-Minds'!!SmartMind methodsFor: 'running' stamp: 'AndrewDong 3/3/2020 21:48'!recoverOn: sketchRobot	"recover the robot in the event of time limit exceeded"	numTles := numTles + 1.	lastDecision = 0 ifTrue: [		neighbourDecisions := neighbourDecisions + 1.	].! !!SmartMind methodsFor: 'running' stamp: 'AndrewDong 3/3/2020 23:17'!initialize	"initializes the mind"		super initialize.		"unchanging parameters; don't adjust"	INF := 1000000.	MAX_ROWS := 100.	MAX_COLS := 100.	DIRS := { 1@0. 0@1. (-1)@0. 0@(-1) }.		"parameters to adjust"	WEIGHT_EXPONENT := 1.0.	NODE_THRESHOLD := 2000.		MAX_DIST := 1000. "maximum distance between any two non-death cells"	DIST_WEIGHT := Array new: MAX_DIST.	1 to: MAX_DIST do: [ :i |		"round to nearest hundredth to avoid expensive floating-point calculations"		DIST_WEIGHT at: i put: ((i raisedTo: WEIGHT_EXPONENT) * 100) rounded / 100.	].		q := Array new: NODE_THRESHOLD.	"queue to hold the moves to make"	moves := Array new: MAX_DIST.	mbeg := 1.	mend := 0.		cells := (Array new: MAX_ROWS) collect: [ :row | Array new: MAX_COLS ].	dist := (Array new: MAX_ROWS) collect: [ :row | Array new: MAX_COLS ].	gain := (Array new: MAX_ROWS) collect: [ :row | Array new: MAX_COLS ].	lastCell := (Array new: MAX_ROWS) collect: [ :row | Array new: MAX_COLS ].	lastDir := (Array new: MAX_ROWS) collect: [ :row | Array new: MAX_COLS ].		"debugging variables; remove before submission"	numTles := 0.	bestNeighboursUsed := 0.	backupMovesUsed := 0.	neighbourDecisions := 0.	lastDecision := -1.	! !!SmartMind methodsFor: 'running' stamp: 'AndrewDong 3/3/2020 21:48'!setupOn: sketchRobot	"sets up the mind"		robot := sketchRobot.		movesLeft := (robot map endTime / robot map cycleTime) asInteger.		ROWS := robot map extent x.	COLS := robot map extent y.		1 to: MAX_ROWS do: [ :i |		1 to: MAX_COLS do: [ :j |			(cells at: i) at: j put: (robot map cellAt: (self normPoint: i@j)).		].	].! !!SmartMind methodsFor: 'processing' stamp: 'AndrewDong 3/3/2020 21:48'!getMove: pt	"get the move that goes towards the given point."		| r c d tr tc |		r := pt x.	c := pt y.	d := (dist at: r) at: c.	d to: 1 by: -1 do: [ :i |		moves at: i put: ((lastDir at: r) at: c).		tr := ((lastCell at: r) at: c) x.		tc := ((lastCell at: r) at: c) y.		r := tr.		c := tc.	].	mbeg := 2.	mend := d.		^ moves at: 1.	! !!SmartMind methodsFor: 'processing' stamp: 'AndrewDong 3/3/2020 21:48'!bfsFrom: pt	"do a breadth-first search from the given point"	| v d g r c val ncell |		1 to: ROWS do: [ :i |		1 to: COLS do: [ :j |			(dist at: i) at: j put: -1.		].	].	(dist at: pt x) at: pt y put: 0.	(gain at: pt x) at: pt y put: 0.	q at: 1 put: pt.	beg := 1.	end := 1.	[ beg <= end ] whileTrue: [		v := q at: beg.		beg := beg + 1.		d := (dist at: v x) at: v y.		g := (gain at: v x) at: v y.		DIRS do: [ :dir |			ncell := self adjTo: (self normPoint: (v + dir)) direction: dir.			r := ncell location x.			c := ncell location y.			(ncell isKindOf: DeathCell) ifFalse: [				val := ncell energy.				((dist at: r) at: c) = -1 ifTrue: [					end < NODE_THRESHOLD ifTrue: [						"push this node if this node hasn't been visited and						the node threshold isn't reached yet"						(dist at: r) at: c put: d + 1.						(gain at: r) at: c put: g + val.						(lastCell at: r) at: c put: v.						(lastDir at: r) at: c put: dir.						end := end + 1.						q at: end put: r@c.					].				].				((dist at: r) at: c) = (d + 1) ifTrue: [					g + val > ((gain at: r) at: c) ifTrue: [						"otherwise, if this node has been visited at this distance						and we would benefit from taking this different route, update						the corresponding values"						(gain at: r) at: c put: g + val.						(lastCell at: r) at: c put: v.						(lastDir at: r) at: c put: dir.					].				].			].		].	].! !!SmartMind methodsFor: 'processing' stamp: 'AndrewDong 3/3/2020 21:48'!getTarget	"select the cell to go to using the optimal shortest path"		| br bc bavg avg r c |		br := 1.	bc := 1.	bavg := INF negated.	2 to: end do: [ :i |		r := (q at: i) x.		c := (q at: i) y.		avg := ((gain at: r) at: c) / (DIST_WEIGHT at: ((dist at: r) at: c)).		avg > bavg ifTrue: [			bavg := avg.			br := r.			bc := c.		].	].	^ br@bc.! !!SmartMind methodsFor: 'competition-api' stamp: 'AndrewDong 3/3/2020 21:51'!determineDirectionForRobot: sketchRobot	| bestNeighbors move |		robot := sketchRobot.	movesLeft := movesLeft - 1.		"debug output"	movesLeft < 3 ifTrue: [		Transcript			show: 'number of TLEs: ';			show: numTles; cr;			show: 'best neighbour decisions made: ';			show: neighbourDecisions; cr;			show: 'best neighbour used ';			show: bestNeighboursUsed;			show: ' times.'; cr;			show: backupMovesUsed;			show: ' backup moves used.'; cr.	].		"code supplied to us for viewing other robots""	allRobots := robot map robots.   otherRobots := allRobots reject: [ :rr | rr id = robot id ].   sortedRobots := otherRobots sorted: [ :r1 :r2 | r1 energy > r2 energy ].   whereRobots := otherRobots collect: [ :rr | rr location ]."	allRobots := robot map robots.	allRobots do: [ :r |		(((cells at: r location x) at: r location y) isKindOf: EnergyCell)		ifTrue: [			((cells at: r location x) at: r location y) energy: 0.		].	].	"if the queue has moves in it, fall back on those; otherwise,	go to the best neighbouring EnergyCell"	mbeg <= mend	ifTrue: [		move := moves at: mbeg.		mbeg := mbeg + 1.		backupMovesUsed := backupMovesUsed + 1.		lastDecision := 1.	]	ifFalse: [		bestNeighboursUsed := bestNeighboursUsed + 1.		lastDecision := 0.		bestNeighbors := robot fourNeighbors sorted: [ :cellA :cellB |			| valA valB |			valA := (cellA isKindOf: EnergyCell) ifTrue: [ cellA energy ] ifFalse: [ INF negated ].			valB := (cellB isKindOf: EnergyCell) ifTrue: [ cellB energy ] ifFalse: [ INF negated ].			valA > valB		].		"if no adjacent cells are EnergyCells, go to any cell that is not a DeathCell"		(bestNeighbors first isKindOf: EnergyCell)		ifFalse: [			bestNeighbors := robot fourNeighbors sorted: [ :cellA :cellB |				(cellA isKindOf: DeathCell) not			].		].		move := robot wrappedVectorTo: bestNeighbors first location.	].	direction := RobotDirection allDirections detect: [ :dir | dir movement = move ].		"do this and return if there's enough time"	self bfsFrom: robot location.	move := self getMove: (self getTarget).	"assign direction to the move we want to make"	direction := RobotDirection allDirections detect: [ :dir | dir movement = move ].! !!SmartMind methodsFor: 'utilities' stamp: 'AndrewDong 3/3/2020 21:48'!normCol: c	"normalizes the given coordinate"	^ c - 1 \\ COLS + 1.! !!SmartMind methodsFor: 'utilities' stamp: 'AndrewDong 3/3/2020 21:48'!adjTo: pt direction: dir	"get the cell that corresponds to reaching this cell	e.g. if it's a warp or jump then returns the landing cell	NOTE: dir is only used to calculate the ending square of a jump"		| cell |		cell := (cells at: pt x) at: pt y.	(cell isKindOf: WarpCell)	ifTrue: [			^ (cells at: cell target x) at: cell target y.	].	(cell isKindOf: JumpCell)	ifTrue: [		^  (cells at: (self normRow: ((cell distance) * (dir x) + pt x))) at: (self normCol: ((cell distance) * (dir y) + pt y)).	].	^ cell! !!SmartMind methodsFor: 'utilities' stamp: 'AndrewDong 3/3/2020 21:48'!normRow: r	"normalizes the given coordinate"	^ r - 1 \\ ROWS + 1.! !!SmartMind methodsFor: 'utilities' stamp: 'AndrewDong 3/3/2020 21:48'!normPoint: pt	"normalizes the given point"	^ (self normRow: pt x)@(self normCol: pt y).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmartMind class	instanceVariableNames: ''!!SmartMind class methodsFor: 'identification' stamp: 'AndrewDong 3/3/2020 21:48'!teamName	^ 'Team Dijkstra'! !