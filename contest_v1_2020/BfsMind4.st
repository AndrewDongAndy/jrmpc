'From Pharo7.0.4 of 13 August 2019 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)] on 25 February 2020 at 9:37:35.381261 pm'!RobotMind subclass: #BfsMind4	instanceVariableNames: 'INF ROWS COLS DIRS DIST_THRESHOLD moves mbeg mend dist gain lastCell lastDir q inMoveSeq'	classVariableNames: ''	poolDictionaries: ''	category: 'JRMPC-Phase1-Minds'!!BfsMind4 methodsFor: 'accessing' stamp: 'AndrewDong 2/24/2020 19:11'!bfsFrom: pt robot: robot	"do a breadth-first search from the given point"	"TODO: use some smoothing, e.g. average of 2x2 grids"	"TODO: constant optimize, e.g. make less objects"	| beg end v d g r c val	br bc tr tc bavg newMoves npt ncell |		"Transcript		show: 'doing bfs from ';		show: pt; cr."			1 to: ROWS do: [ :i |		1 to: COLS do: [ :j |			(dist at: i) at: j put: -1.			(gain at: i) at: j put: 0.		].	].	(dist at: pt x) at: pt y put: 0.	q at: 1 put: pt.	beg := 1.	end := 1.	[ beg <= end ]	whileTrue: [		v := q at: beg.		beg := beg + 1.		d := (dist at: v x) at: v y. "distance of this node"		d <= DIST_THRESHOLD ifTrue: [					g := (gain at: v x) at: v y. "gain at this node"		DIRS do: [ :dir |			npt := self normPoint: (v + dir).			ncell := self adjTo: robot point: npt direction: dir.			r := ncell location x.			c := ncell location y.			(ncell isKindOf: DeathCell)			ifFalse: [				val := ncell energy.				"check whether or not to push this node"				((dist at: r) at: c) = -1				ifTrue: [					(dist at: r) at: c put: d + 1.					(gain at: r) at: c put: g + val.					(lastCell at: r) at: c put: v.					(lastDir at: r) at: c put: dir.					end := end + 1.					q at: end put: (r@c).				]				ifFalse: [					((((dist at: r) at: c) = (d + 1)) and: ((g + val) > ((gain at: r) at: c)))					ifTrue: [						(gain at: r) at: c put: g + val.						(lastCell at: r) at: c put: v.						(lastDir at: r) at: c put: dir.					].				].			].		].		].	].	"now, select the cell to go to, using the optimal shortest path"	br := 1.	bc := 1.	bavg := INF negated.	1 to: ROWS do: [ :i |		1 to: COLS do: [ :j |			d := (dist at: i) at: j.			g := (gain at: i) at: j.			d > 0 ifTrue: [				| avg |				avg := g / d.				avg > bavg ifTrue: [					bavg := avg.					br := i.					bc := j.				].			].		].	].	"Transcript		show: 'going to cell (';		show: br;		show: ', ';		show: bc;		show: ') with average gain ';		show: bavg; cr."	d := (dist at: br) at: bc.	newMoves := Array new: d.	r := br.	c := bc.			1 to: d do: [ :i |		newMoves at: i put: ((lastDir at: r) at: c).		tr := ((lastCell at: r) at: c) x.		tc := ((lastCell at: r) at: c) y.		r := tr.		c := tc.	].	self pushMove: (newMoves at: d).	"newMoves reverseDo: [ :move |		self pushMove: move.	]."! !!BfsMind4 methodsFor: 'competition-api' stamp: 'AndrewDong 2/24/2020 18:53'!determineDirectionForRobot: robot	| bestNeighbors bestMovement move allRobots otherRobots sortedRobots whereRobots |		"code supplied to us for viewing other robots"	allRobots := robot map robots.   otherRobots := allRobots reject: [ :r | r id = robot id ].   sortedRobots := otherRobots sorted: [ :r1 :r2 | r1 energy > r2 energy ].   whereRobots := otherRobots collect: [ :r | r location ].		"fall back on bestNeighbors if time limit exceeded this turn"	bestNeighbors := robot fourNeighbors sorted: [ :cellA :cellB |		| valA valB |		valA := (cellA isKindOf: EnergyCell) ifTrue: [ cellA energy ] ifFalse: [ INF negated ].		valB := (cellB isKindOf: EnergyCell) ifTrue: [ cellB energy ] ifFalse: [ INF negated ].		valA > valB	].	"if no adjacent cells are EnergyCells, go to any cell that is not a DeathCell"	(bestNeighbors first isKindOf: EnergyCell)	ifFalse: [		bestNeighbors := robot fourNeighbors sorted: [ :cellA :cellB |			(cellA isKindOf: DeathCell) not		].	].	bestMovement := robot wrappedVectorTo: bestNeighbors first location.	direction := RobotDirection allDirections detect: [ :dir | dir movement = bestMovement ].		self resetMoves.		"if the move queue is empty then do BFS again"	(mbeg > mend)	ifTrue: [		self bfsFrom: (robot location) robot: robot.	].		"assign direction to the move we want to make"	move := self popMove.	direction := RobotDirection allDirections detect: [ :dir | dir movement = move ].	! !!BfsMind4 methodsFor: 'running' stamp: 'AndrewDong 2/24/2020 18:54'!recoverOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 If the mind doesn't complete its step within the designated time, its process is terminated.	 Depending on how you manage your data objects, they may end up corrupted.	 This method allows the mind to reset and continue playing. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"	Transcript show: 'time limit exceeded; recovering'; cr.	self setupOn: sketchRobot.! !!BfsMind4 methodsFor: 'running' stamp: 'AndrewDong 2/24/2020 18:26'!setupOn: robot	"sets up the mind"	Transcript		show: '==========START OF NEW RUN OF ';		show: self class name;		show: '=========='; cr.	INF := 1000000.	ROWS := robot map extent x.	COLS := robot map extent y.	DIRS := { 1@0. 0@1. -1@0. 0@(-1) }.	DIST_THRESHOLD := 100. "set to a large number for unrestricted search"		q := Array new: (ROWS * COLS).		"dist: a 2d array of ints showing the dist given by the BFS"	"gain: a 2d array of ints storing the number of points gained on the path from pt to each point"	"lastCell: a 2d array of points stating the previous cell before coming to this cell"	dist := (Array new: ROWS) collect: [ :row | Array new: COLS ].	gain := (Array new: ROWS) collect: [ :row | Array new: COLS ].	lastCell := (Array new: ROWS) collect: [ :row | Array new: COLS ].	lastDir := (Array new: ROWS) collect: [ :row | Array new: COLS ].	moves := Array new: 1000.	self resetMoves.! !!BfsMind4 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:26'!normPoint: pt	"normalizes the given point"	^ (self normRow: pt x)@(self normCol: pt y).! !!BfsMind4 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:26'!normCol: c	"normalizes the given coordinate"	^ c - 1 \\ COLS + 1.! !!BfsMind4 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 19:12'!adjTo: robot point: pt direction: dir	"get the cell that corresponds to reaching this cell	e.g. if it's a warp or jump then returns the landing cell	NOTE: dir is only used to calculate the ending square of a jump"		| cell r c |	r := pt x.	c := pt y.	cell := robot map cellAt: r@c.	(cell isKindOf: WarpCell)	ifTrue: [			r := cell target x.		c := cell target y.		cell := robot map cellAt: r@c.	].	(cell isKindOf: JumpCell)	ifTrue: [		| jumpDist |		jumpDist := cell distance.		r := self normRow: (r + (jumpDist * (dir x))).		c := self normCol: (c + (jumpDist * (dir y))).		cell := robot map cellAt: r@c.	].	^ cell! !!BfsMind4 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:26'!pushMove: pt	"pushes the given point to the queue."	mend := mend + 1.	moves at: mend put: pt.! !!BfsMind4 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:26'!popMove	"pops the move from the start of the queue moves and returns it"	mbeg := mbeg + 1.	^ moves at: (mbeg - 1).! !!BfsMind4 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:26'!normRow: r	"normalizes the given coordinate"	^ r - 1 \\ ROWS + 1.! !!BfsMind4 methodsFor: 'initialization' stamp: 'AndrewDong 2/24/2020 18:26'!resetMoves	"resets the queue of moves"		mbeg := 1.	mend := 0.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BfsMind4 class	instanceVariableNames: ''!!BfsMind4 class methodsFor: 'identification' stamp: 'AndrewDong 2/24/2020 18:26'!teamName	^'Competition Organizer'! !