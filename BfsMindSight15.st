'From Pharo7.0.4 of 13 August 2019 [Build information: Pharo-7.0.4+build.168.sha.ccd1f6489120f58ddeacb2cac77cd3a0f0dcfbe6 (64 Bit)] on 25 February 2020 at 9:37:44.763261 pm'!RobotMind subclass: #BfsMindSight15	instanceVariableNames: 'INF ROWS COLS DIRS DIST_THRESHOLD moves mbeg mend dist gain lastCell lastDir q inMoveSeq'	classVariableNames: ''	poolDictionaries: ''	category: 'JRMPC-Phase1-Minds'!!BfsMindSight15 methodsFor: 'running' stamp: 'AndrewDong 2/24/2020 18:27'!recoverOn: sketchRobot	"COMPETITION ENTRIES _MAY_ OVERRIDE THIS METHOD.	 If the mind doesn't complete its step within the designated time, its process is terminated.	 Depending on how you manage your data objects, they may end up corrupted.	 This method allows the mind to reset and continue playing. 	 'sketchRobot' is a copy of the world as seen by the robot's scanners 	"	Transcript show: 'time limit exceeded; recovering'; cr.	self setupOn: sketchRobot! !!BfsMindSight15 methodsFor: 'running' stamp: 'AndrewDong 2/24/2020 18:27'!setupOn: robot	"sets up the mind"	Transcript		show: '==========START OF NEW RUN OF ';		show: self class name;		show: '=========='; cr.	INF := 1000000.	ROWS := robot map extent x.	COLS := robot map extent y.	DIRS := { 1@0. 0@1. -1@0. 0@(-1) }.	DIST_THRESHOLD := 15. "set to a large number for unrestricted search"		q := Array new: (ROWS * COLS).		"dist: a 2d array of ints showing the dist given by the BFS"	"gain: a 2d array of ints storing the number of points gained on the path from pt to each point"	"lastCell: a 2d array of points stating the previous cell before coming to this cell"	dist := (Array new: ROWS) collect: [ :row | Array new: COLS ].	gain := (Array new: ROWS) collect: [ :row | Array new: COLS ].	lastCell := (Array new: ROWS) collect: [ :row | Array new: COLS ].	lastDir := (Array new: ROWS) collect: [ :row | Array new: COLS ].	moves := Array new: 1000.	self resetMoves.! !!BfsMindSight15 methodsFor: 'competition-api' stamp: 'AndrewDong 2/24/2020 18:27'!determineDirectionForRobot: robot	| bestNeighbors bestMovement move |		bestNeighbors := robot fourNeighbors sorted: [ :cellA :cellB | cellA energy > cellB energy ].	bestMovement := robot wrappedVectorTo: bestNeighbors first location.	direction := RobotDirection allDirections detect: [ :dir | dir movement = bestMovement ].		self resetMoves.		"if the move queue is empty then do BFS again"	(mbeg > mend) ifTrue: [ self bfsFrom: (robot location) robot: robot. ].		"assign direction to the move we want to make"	move := self popMove.	direction := RobotDirection allDirections detect: [ :dir | dir movement = move ].! !!BfsMindSight15 methodsFor: 'accessing' stamp: 'AndrewDong 2/24/2020 18:27'!bfsFrom: pt robot: robot	"do a breadth-first search from the given point"	"TODO: use some smoothing, e.g. average of 2x2 grids"	"TODO: constant optimize, e.g. make less objects"	| beg end v d g r c val	br bc tr tc bavg newMoves npt ncell |		"Transcript		show: 'doing bfs from ';		show: pt; cr."			1 to: ROWS do: [ :i |		1 to: COLS do: [ :j |			(dist at: i) at: j put: -1.			(gain at: i) at: j put: 0.		].	].	(dist at: pt x) at: pt y put: 0.	q at: 1 put: pt.	beg := 1.	end := 1.	[ beg <= end ]	whileTrue: [		v := q at: beg.		beg := beg + 1.		d := (dist at: v x) at: v y. "distance of this node"		d <= DIST_THRESHOLD ifTrue: [					g := (gain at: v x) at: v y. "gain at this node"		DIRS do: [ :dir |			npt := self normPoint: (v + dir).			ncell := robot map cellAt: npt.			r := npt x.			c := npt y.						"process this node; check types of squares it could be"			"this code makes it possible for, e.g., a jump or warp to land on a death square"			(ncell isKindOf: WarpCell)			ifTrue: [				"Transcript					show: 'warp cell at ';					show: r@c."				r := ncell target x.				c := ncell target y.				"Transcript					show: ' goes to ';					show: r@c; cr."				ncell := robot map cellAt: r@c.			].						(ncell isKindOf: JumpCell)			ifTrue: [				| jumpDist |				jumpDist := ncell distance.				"Transcript					show: 'jump cell at ';					show: r@c."				r := self normRow: (r + (jumpDist * (dir x))).				c := self normCol: (c + (jumpDist * (dir y))).				"Transcript					show: ' goes to ';					show: r@c; cr."				ncell := robot map cellAt: r@c.			].						(ncell isKindOf: DeathCell)			ifTrue: [				"Transcript					show: 'death cell at ';					show: r@c; cr."			]			ifFalse: [				val := ncell energy.				"check whether or not to push this node"				((dist at: r) at: c) = -1				ifTrue: [					(dist at: r) at: c put: d + 1.					(gain at: r) at: c put: g + val.					(lastCell at: r) at: c put: v.					(lastDir at: r) at: c put: dir.					end := end + 1.					q at: end put: (r@c).				]				ifFalse: [					((((dist at: r) at: c) = (d + 1)) and: ((g + val) > ((gain at: r) at: c)))					ifTrue: [						(gain at: r) at: c put: g + val.						(lastCell at: r) at: c put: v.						(lastDir at: r) at: c put: dir.					].				].			].		].		].	].	"now, select the cell to go to, using the optimal shortest path"	br := 1.	bc := 1.	bavg := INF negated.	1 to: ROWS do: [ :i |		1 to: COLS do: [ :j |			d := (dist at: i) at: j.			g := (gain at: i) at: j.			d > 0 ifTrue: [				| avg |				avg := g / d.				avg > bavg ifTrue: [					bavg := avg.					br := i.					bc := j.				].			].		].	].	"Transcript		show: 'going to cell (';		show: br;		show: ', ';		show: bc;		show: ') with average gain ';		show: bavg; cr."	d := (dist at: br) at: bc.	newMoves := Array new: d.	r := br.	c := bc.	1 to: d do: [ :i |		newMoves at: i put: ((lastDir at: r) at: c).		tr := ((lastCell at: r) at: c) x.		tc := ((lastCell at: r) at: c) y.		r := tr.		c := tc.	].	newMoves reverseDo: [ :move |		self pushMove: move.	].! !!BfsMindSight15 methodsFor: 'initialization' stamp: 'AndrewDong 2/24/2020 18:27'!resetMoves	"resets the queue of moves"		mbeg := 1.	mend := 0.	! !!BfsMindSight15 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:27'!normPoint: pt	"normalizes the given point"	^ (self normRow: pt x)@(self normCol: pt y).! !!BfsMindSight15 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:27'!normCol: c	"normalizes the given coordinate"	^ c - 1 \\ COLS + 1.! !!BfsMindSight15 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:27'!pushMove: pt	"pushes the given point to the queue."	mend := mend + 1.	moves at: mend put: pt.! !!BfsMindSight15 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:27'!popMove	"pops the move from the start of the queue moves and returns it"	mbeg := mbeg + 1.	^ moves at: (mbeg - 1).! !!BfsMindSight15 methodsFor: 'as yet unclassified' stamp: 'AndrewDong 2/24/2020 18:27'!normRow: r	"normalizes the given coordinate"	^ r - 1 \\ ROWS + 1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BfsMindSight15 class	instanceVariableNames: ''!!BfsMindSight15 class methodsFor: 'identification' stamp: 'AndrewDong 2/24/2020 18:27'!teamName	^'Competition Organizer'! !